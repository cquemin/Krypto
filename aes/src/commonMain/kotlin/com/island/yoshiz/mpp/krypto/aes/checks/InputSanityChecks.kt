package com.island.yoshiz.mpp.krypto.aes.checks

import com.island.yoshiz.mpp.krypto.aes.model.config.AesBlockMode
import com.island.yoshiz.mpp.krypto.aes.model.exceptions.AesInvalidIvException
import com.island.yoshiz.mpp.krypto.common.utils.logWarning

/**
 * Implements a `secure` behaviour for the method exposed by the super class [AesSanityChecks].
 * In particular if [onIvNotSecureToUse] is invoked it will throw an [AesInvalidIvException]
 */
internal class AesInputSanityCheck(mode: AesBlockMode) : AesSanityChecks(mode) {

    override fun onIvNotSecureToUse() {
        throw AesInvalidIvException(
                "\nThis Iv is not initialised. Using a zero'd IV is highly unsecure.\n" +
                        "If it is for encryption consider removing the IV and let the library generates " +
                        "one for you.\nIf it is for decryption consider decrypting the data and re encrypting" +
                        "it with a random IV or one generated by this engine"
        )
    }
}

/**
 * Implements a `NON secure` behaviour for the method exposed by the super class [AesSanityChecks].
 * In particular if [onIvNotSecureToUse] returns false it will log a warning
 */
internal class AesInputSanityCheckNotSecure(mode: AesBlockMode) : AesSanityChecks(mode) {

    private val logTag = "AesInputSanityCheckNotSecure"

    override fun onIvNotSecureToUse() {
        logWarning(logTag) {
            "This Iv is not initialised. Using a zero'd IV is highly unsecure " +
                    "If it is for encryption consider removing the IC and let the library generates " +
                    "one for you. If it is for decryption consider decrypting the data and re encrypting" +
                    "it with a random IV or one generated by this engine"
        }
    }
}

